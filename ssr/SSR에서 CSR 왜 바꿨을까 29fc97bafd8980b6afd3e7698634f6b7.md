# SSR에서 CSR 왜 바꿨을까?

Created: November 2, 2025 12:33 PM
Tags: Next.js, React, 성능
Date: 2025/11/02
Summary: 우아콘을 통해 웹뷰 성능 개선 딥다이브하기

![](https://github.com/SeoJaeWan/SeoJaeWan/blob/master/thumb/4517077b-4883-4b8c-96a8-c844e56876f5.png?raw=true)

우아콘을 통해서 Next.js에서 React로 그리고 추가적인 성능을 개선한 부분에 대한 발표를 듣고 딥다이브를 해보기로 결심했습니다. 

큰 단락으로는 다음과 같았습니다. 

- SSR → CSR
- Critical JavaScript
- 서버드리븐 UI
- Image lazy load
- Code Splitting
- Tanstack Virtual

# SSR → CSR

최초 웹뷰를 개발할 때는 SSR인 Next.js를 사용해서 개발을 진행했다고 합니다. 그리고 웹뷰에 적용하고 보니 네이티브와는 먼가 다른 어색한 동작과 로딩이 있다고 했습니다. 

로드 시간은 사용자 경험에 아주 큰 영향을 주는 부분으로 [**1초 증가할 때마다 조회수가 4.9% 감소**](https://medium.com/ft-product-technology/a-faster-ft-com-10e7c077dc1c)하고, [**0.1초 개선되면 추가 매출이 1% 증가**](https://www.slideshare.net/slideshow/walmart-pagespeedslide/25991009)했다는 기록이 있을 정도니까요. 

![우아콘 발표 내용 중.](image.png)

우아콘 발표 내용 중.

사진에서 알 수 있듯 SSR 방식으로 개발을 한다면 필수 API 데이터를 호출하고 다운로드, 렌더까지 진행 후 FCP가 완료되고, CSR은 최소 JS만 먼저 실행해 **skeleton을 빠르게 그리기 쉬워** FCP를 앞당기기 유리합니다

핵심은 필수 API를 서버에서 전달받는 시점에서 완료가 되는지, FCP 이후 완료가 되는지에 따라 FCP가 달라집니다. 

배달의 민족은 이러한 결과를 보고 SSR과 CSR의 트레이드 오프에 대해서 비교했습니다. 

- **SEO가 필요한 서비스인가?** 
→ 앱 내에서만 사용되는 웹뷰라서 SEO가 필요없음.
- **SSR로 인해 초기 로딩이 오히려 느려짐**
→ 빠른 초기 로딩을 위해서는 CSR을 사용하는게 이득

## SSR 사용하지 않는게 최선일까?

그런데, 이부분에서 한가지 의문이 생겼습니다. 

SSR이 초기 로딩이 느리다는 부분은 이해가 될 수 있는 부분입니다. 서버에서 데이터를 SSR로 불러온다면 API 호출이 완료 된 후 사용자에게 HTML 페이지를 넘겨주기 때문에 CSR에 비해 **“초기 화면”**은 늦게 나올 수 있습니다. 

> “ CSR은 HTML 자체는 더 빠르게 넘어와서 이때 **스켈레톤 화면을 보여주면 되기 때문에** “
> 

## SSR에서의 방법은 없는 것일까?

CSR이 FCP가 더 빠르다는 것은 대체로 맞지만, SSR도 스트리밍, 분할 렌더, skeleton을 서버에서 바로 그려서 보내준다면 **FCP를 충분하게 앞당길 수 있습니다.** 

**1. 두 가지 SSR 모드 : Blocking vs Streaming**

SSR은 2가지 형식으로 구성되어 있습니다. 

- **Blocking(전통적 SSR)** : 서버가 모든 데이터 로딩 + 템플릿 렌더를 마치고 **완성 HTML**을 한 번에 보냄 
→ TTFB ↑, FCP도 뒤로 밀릴 수 있음.
- **Streaming SSR** : **서버가 그릴 수 있는 부분과 스켈레톤을 먼저** 보내고, **데이터 의존 영역은 나중에** 보냄 
→ 브라우저는 조각을 받는 즉시 그려서 FCP를 앞당김

**2. 그렇다면 어떻게 구현하나?** 

1. **레이아웃 / 헤더 / 푸터** 등 데이터 **비의존 셸을 분리**합니다. 
2. **데이터 의존 컴포넌트는 Suspense 경계**로 감싸고 fallback을 서버에서 그려 보내줄 수 있는 스켈레톤으로 설계합니다. 
3. **스트리밍 응답**을 활성화 합니다. (Next App Router / RSC는 기본적으로 스트리밍이 가능)
4. 초기 청크에 : 
    - 필수 **문서 구조** (<html>, <head>, <body>)
    - **크리티컬 스크립트**
    - **셸 HTML + 스켈레톤**
    
    을 포함시킵니다. 
    
5. 후속 청크에 : 
    - **데이터가 준비된 섹션의 실제 마크업**
    - **나머지 JS 청크**
    
    를 순차적으로 전송합니다. 
    

```jsx
// 서버 컴포넌트 (Next App Router 가정)
import { Suspense } from "react";
import { Reviews } from "./Reviews"; // 데이터 의존

export default function Page() {
  return (
    <>
      <Header /> {/* 데이터 비의존 → 초기 청크에 포함, 즉시 그려짐 */}
      <HeroSkeleton /> {/* 스켈레톤도 서버에서 바로 렌더 */}
      <Suspense fallback={<ReviewsSkeleton />}>
        {/* 데이터가 오면 이 영역만 실제 컨텐츠로 교체되는 청크가 뒤이어 옴 */}
        <Reviews />
      </Suspense>
      <Footer />
    </>
  );
}
```

이렇게 하면 **Header/Hero/스켈레톤**이 먼저 도착해 **FCP를 찍고**, Reviews 데이터가 도착하는 순간 **후속 청크**가 와서 **해당 영역만 갱신**됩니다. 

## Streaming SSR vs CSR

지금까지의 내용을 정리해 보면, **FCP를 앞당기기 위한 방법**으로는 크게 두 가지 축을 생각해 볼 수 있습니다.

- CSR에서 **HTML에 스켈레톤/로딩 UI를 미리 넣어두는 방식**
- Streaming SSR을 이용해서 **서버에서 렌더링된 HTML을 스트리밍하는 방식**

먼저 CSR부터 보겠습니다.

### CSR에서의 FCP

1. HTML 응답 수신
2. JS 번들 다운로드
3. JS 파싱 + 실행 → React 실행
4. React가 실제 UI를 렌더링

보통 아무것도 안 하면, **4번에서 처음으로 컨텐츠가 그려지기 때문에 이 시점이 FCP**가 됩니다.
하지만 HTML 안에 스켈레톤 UI를 미리 넣어두면 **1번 단계에서 FCP**를 만들 수도 있습니다.

```jsx
<body>
  <div id="root">
    <div class="skeleton-list">...</div>
  </div>
  <script src="/bundle.js"></script>
</body>
```

이 경우 브라우저는 **HTML + CSS만 받아도 스켈레톤을 그릴 수 있기 때문에**, JS를 기다리지 않고도 매우 빠르게 FCP를 찍을 수 있습니다.

이후 JS 번들이 로드되고 실행되면, 스켈레톤을 실제 데이터가 있는 UI로 교체하게 됩니다.
이번 비교에서는 **CSR에서도 HTML에 스켈레톤을 넣어 둔 경우(1번에서 FCP 발생)**를 기준으로,

Streaming SSR과의 FCP 체감을 비교해 보겠습니다.

### Streaming SSR에서의 FCP

1. 서버에서 API를 사용하지 않는 요소나 fallback UI를 렌더링하고,
    
    준비되는 대로 첫 HTML chunk를 스트리밍 시작
    
2. 브라우저는 이 첫 chunk를 받는 즉시 파싱하고 그려서 **FCP를 찍음**
3. 서버는 백그라운드에서 무거운 데이터를 계속 가져옴
4. 준비가 끝난 HTML을 추가 chunk로 스트리밍하여, 화면의 나머지 영역을 점진적으로 채움

즉, Streaming SSR에서는 **브라우저가 첫 chunk를 그리는 시점(2번 단계)**이 FCP가 됩니다.

이 chunk에는 레이아웃 셸이나 fallback UI(스켈레톤 등)가 포함될 수 있습니다.

### FCP만 놓고 비교했을 때의 결론

동일한 수준의 “껍데기 UI”를 비교한다고 가정하면:

- **CSR + HTML 스켈레톤**
    - 서버는 미리 만들어 둔 정적 HTML을 그대로 반환하기만 하면 되기 때문에
        
        서버 렌더링 비용이 거의 없습니다.
        
    - 브라우저는 HTML만 받아도 곧바로 스켈레톤을 그릴 수 있어서
        
        이론적으로 FCP를 매우 빠르게 만들 수 있습니다.
        
- **Streaming SSR**
    - 서버에서 React 렌더링을 한 번 거쳐서 HTML chunk를 만들어야 하므로
        
        그만큼 TTFB/FCP가 늦어질 여지가 있습니다.
        

그래서 **“동일한 스켈레톤 UI를 보여준다”는 조건과
“서버 렌더링 비용을 그대로 포함한다”는 조건 아래에서,
순수하게 FCP만 비교하면 CSR 쪽이 더 유리해질 가능성이 높은 편**이라고 볼 수 있습니다.

다만, Streaming SSR은 **실제 데이터가 채워진 영역을 스트리밍으로 조금 더 일찍 보여줄 수 있다**는 장점이 있기 때문에, 실무에서는 FCP 단일 지표보다는 **“사용자 체감이 큰 블록을 언제까지 스켈레톤으로 둘지 / 언제부터 실제 데이터를 보여줄지”**를 기준으로 Suspense 경계를 나누는 것이 중요합니다.

또 너무 과하게 Suspense를 쪼개면 네트워크/DOM 오버헤드가 늘어날 수 있기 때문에,사용자 체감이 큰 영역 위주로 스트리밍을 적용하는 것이 더 현실적인 전략입니다.

## SSG도 있는데요?

하지만, Next.js에는 SSR로만 개발할 수 있는게 아니고 SSG로 개발할 수 있습니다. 또한 해당 세션을 듣고 연사님과 같은 팀인 프론트엔드 개발자님께 질문했을 때, 배달의 민족의 프론트 기술 방향이 **Node 서버**를 사용하지 않는 쪽으로 결정되어 있다고 답변을 받았습니다.

---

*** Node 서버를 사용하지 않는다?** 

Node 서버를 사용하지 않는다는 것은 결국 [**static export**](https://nextjs.org/docs/app/guides/static-exports)를 사용하는 방향이기 때문에 SSG 방식으로 배포가 되기 때문에 정적 배포로 웹뷰를 보여주는 방식이니 결과적으로 CSR과 큰 차이가 없다고 생각이 들었습니다. 

---

그렇다면, 굳이 Next.js에서 React로 넘어갈 필요가 있었을지 의문이 생겼습니다. 

- 초기 로드 속도 개선 관점에서는, **정적 배포 후에 개인화 데이터를 CSR처럼 초기 렌더 이후 필수 API를 호출해 주입**하는 방식으로 운용이 가능해 보입니다.
- 이 경우 **CSR과 SSG 간 체감 차이가 크지 않을 수 있고**, 최적화 기법은 양쪽 모두 사용이 가능하다.

팀 자체에서 Next.js를 사용하고 있었다면 더욱 팀 생산성 측면에서도 Next.js가 더 좋은 선택일 수 있을 것 같았다. 

조금 더 고민해봤을 때 생각해보면 static export를 사용하는 방향이라면 추후 **화면을 구성하는 페이지**가 생길 때마다 **추가 배포를 진행하거나 주기적으로 배포 플로우**를 타야한다는 생각이 들었습니다. 

예를 들어, 배달의 민족에서 장보기 페이지 내에서 최초에는 CU, 세븐일레븐만 입점했다가 추후 GS25가 입점했다고 생각하면 SSG 기준에서는 GS25 페이지는 재배포가 발생하기 전까지는 제대로 이용할 수 없는 이슈가 생깁니다. 

이부분을 자동화를 하더라도 배포 작업을 거친다는 것은 분명 **예상치 못한 리스크**가 발생할 수 있으므로 선택하지 않을 이유가 될 수 있을 것 같습니다. 

# 결국 선택의 기준은?

운영 방식에 따라 세 가지 모두 유효한 선택지가 될 수 있습니다.

- **SEO 중요도 낮음 + 화면 증설/변경이 잦음 ⇒ CSR**
    - 배포 없이도 화면을 자주 바꾸고 싶을 때
- **SEO 중요 + “의미 있는 픽셀”을 최대한 빨리 ⇒ SSR / Streaming SSR**
    - 검색 유입이 중요하고, 첫 화면 신뢰·완성도가 중요한 서비스일 때
- **페이지 수가 비교적 고정 + 배포 파이프라인에 대한 신뢰 높음 ⇒ SSG**
    - 문서/콘텐츠 위주 서비스처럼 구조가 크게 변하지 않고,
        
        빌드·배포 자동화가 잘 갖춰져 있을 때
        

여기에 **정답은 하나로 고정돼 있지 않습니다.**

팀의 환경, 개발 문화, 인프라 한계, 운영 인력 등 **맥락에 따라 최선의 선택은 달라질 수 있습니다.**

중요한 것은 프레임워크 이름이 아니라 **설계 원칙**입니다.

어떤 방식을 택하더라도,

- 사용자의 **체감 속도를 높이고**
- **전환(Conversion)까지의 경험을 얼마나 매끄럽게 만들 수 있는지**

를 기준으로 판단하는 게 더 중요합니다.

그 관점에서 보면, 프레임워크는 어디까지나 **그 목표를 이루기 위한 수단**일 뿐입니다.